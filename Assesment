// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract SubscriptionService {
    struct Subscriber {
        address subscriberAddress;
        uint256 subscriptionEnd;
        bool isSubscribed;
    }

    mapping(address => Subscriber) public subscribers;
    address public owner;
    uint256 public subscriptionFee;
    uint256 public subscriptionDuration; // in seconds

    constructor(uint256 _subscriptionFee, uint256 _subscriptionDuration) {
        owner = msg.sender;
        subscriptionFee = _subscriptionFee;
        subscriptionDuration = _subscriptionDuration;
    }

    modifier onlyOwner() {
        require(msg.sender == owner, "Not authorized");
        _;
    }

    modifier onlySubscriber() {
        require(subscribers[msg.sender].isSubscribed, "Not subscribed");
        _;
    }

    // Subscribe to the service
    function subscribe() public payable {
        require(msg.value == subscriptionFee, "Incorrect subscription fee");

        Subscriber storage subscriber = subscribers[msg.sender];
        
        if (subscriber.isSubscribed) {
            revert("Already subscribed");
        }

        subscriber.subscriberAddress = msg.sender;
        subscriber.subscriptionEnd = block.timestamp + subscriptionDuration;
        subscriber.isSubscribed = true;

        assert(subscriber.isSubscribed == true);
    }

    // Renew subscription
    function renewSubscription() public payable onlySubscriber {
        require(msg.value == subscriptionFee, "Incorrect subscription fee");

        Subscriber storage subscriber = subscribers[msg.sender];
        subscriber.subscriptionEnd += subscriptionDuration;

        assert(subscriber.subscriptionEnd > block.timestamp);
    }

    // Cancel subscription
    function cancelSubscription() public onlySubscriber {
        Subscriber storage subscriber = subscribers[msg.sender];
        subscriber.isSubscribed = false;

        assert(subscriber.isSubscribed == false);
    }

    // Check if a user is subscribed
    function isSubscribed(address _user) public view returns (bool) {
        Subscriber storage subscriber = subscribers[_user];
        return subscriber.isSubscribed && (subscriber.subscriptionEnd > block.timestamp);
    }

    // Withdraw funds from the contract
    function withdraw() public onlyOwner {
        payable(owner).transfer(address(this).balance);
    }
}
